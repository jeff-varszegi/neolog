/***********************************************************************************************************************
*  MIT License: NeoLog, A High-Performance Logging System. (https://github.com/NeoLog)                                 *
*  Copyright (c) 2019 Jeffrey Varszegi                                                                                 *
*                                                                                                                      *
*  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated        *
*  documentation files (the "Software"), to deal in the Software without restriction, including without limitation     *
*  the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and    *
*  to permit persons to whom the Software is furnished to do so, subject to the following conditions:                  *
*                                                                                                                      *
*  The above copyright notice and this permission notice shall be included in all copies or substantial portions of    *
*  the Software.                                                                                                       *
*                                                                                                                      *
*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO    *
*  THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE      *
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF           *
*  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS   *
*  IN THE SOFTWARE.                                                                                                    *
***********************************************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

using NeoLog.Formatting.Patterns.Tokens;

namespace NeoLog.Formatting.Patterns
{
    /// <summary>Registers token types with matching patterns, and creates tokens</summary>
    public sealed class TokenFactory
    {
        /// <summary>A token builder which uses a registered type</summary>
        private class TypeTokenBuilder : ITokenBuilder
        {
            /// <summary>The token type generated by this builder</summary>
            public Type TokenType { get; private set; }

            private Regex tokenRegex;

            /// <summary>Constructs a new instance</summary>
            /// <param name="tokenType">The type to use in token creation</param>
            /// <param name="tokenRegex">The regular expression for the token to build</param>
            public TypeTokenBuilder(Type tokenType, Regex tokenRegex)
            {
                this.TokenType = tokenType;
                this.tokenRegex = tokenRegex;
            }

            /// <summary>Indicates whether this builder can build a token for the specified text</summary>
            /// <param name="tokenText">The text of the token occurring inside a pattern</param>
            /// <returns>true if this builder handles the token text, otherwise false</returns>
            public bool Handles(string tokenText)
            {
                return tokenRegex.IsMatch(tokenText);
            }

            /// <summary>Builds a token with the specified text</summary>
            /// <param name="text">The source text of the token</param>
            /// <returns>A new token</returns>
            public Token BuildToken(string text)
            {
                return (Token)Activator.CreateInstance(TokenType, new string[] { text });
            }
        }

        /// <summary>A canonical empty-text token, as a friendliness measure to avoid throwing exceptions</summary>
        private static Token EmptyToken = new TextToken("");

        /// <summary>The type of the token base class</summary>
        private static Type TokenBaseType = typeof(Token);

        /// <summary>A default/singleton instance</summary>
        public static TokenFactory Default { get; } = new TokenFactory();

        /// <summary>Static initializer</summary>
        static TokenFactory()
        {
            // Activate any self-registration code in token classes at startup
            foreach (Type type in AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(type => TokenBaseType.IsAssignableFrom(type)))
            {
                try { Activator.CreateInstance(type, ""); } catch { }
            }
        }

        /// <summary>A list of token builders</summary>
        private ITokenBuilder[] tokenBuilders = {};

        /// <summary>Tracks already-registered token types</summary>
        private HashSet<string> registeredTokenTypes = new HashSet<string>();

        /// <summary>Used in synchronization</summary>
        private object monitor = new object();

        /// <summary>Registers the specified token factory to handle the indicated pattern</summary>
        /// <param name="builder">The factory to register</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Register(ITokenBuilder builder)
        {
            if (builder == null) throw new ArgumentNullException();

            lock (monitor)
            {
                if (!registeredTokenTypes.Contains(builder.TokenType.FullName))
                {
                    List<ITokenBuilder> list = tokenBuilders.ToList();
                    list.Add(builder);
                    tokenBuilders = list.ToArray();
                    registeredTokenTypes.Add(builder.TokenType.FullName);
                }
            }
        }

        /// <summary>Registers the specified token type to handle the indicated pattern</summary>
        /// <param name="type">The type to register</param>
        /// <param name="tokenPattern">The pattern to associate with the registry</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Register(Type tokenType, string tokenPattern)
        {
            if (tokenType == null) throw new ArgumentNullException("tokenType");
            else if (!TokenBaseType.IsAssignableFrom(tokenType)) throw new ArgumentException("Type " + tokenType.FullName + " is not a token type");
            else if (string.IsNullOrWhiteSpace(tokenPattern)) throw new ArgumentException("Invalid (null or whitespace) token pattern");

            Regex tokenRegex = new Regex(tokenPattern, RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);
            Register(new TypeTokenBuilder(tokenType, tokenRegex));
        }

        /// <summary>Registers the specified token type to handle the indicated pattern</summary>
        /// <param name="tokenTypeName">The type to register</param>
        /// <param name="tokenPattern">The pattern to associate with the registry</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Register(string tokenTypeName, string tokenPattern)
        {
            if (string.IsNullOrWhiteSpace(tokenTypeName)) throw new ArgumentException("Invalid (null or whitespace) type name");
            else if (string.IsNullOrWhiteSpace(tokenPattern)) throw new ArgumentException("String \"" + tokenPattern + "\" is not a valid token pattern");

            Type type = null;
            try
            {
                type = Type.GetType(tokenTypeName);
                if (type == null) throw new InvalidOperationException();
            }
            catch
            {
                throw new InvalidOperationException("Cannot get type \"" + tokenTypeName + "\"");
            }

            Register(type, tokenPattern);
        }

        /// <summary>Creates a token for the specified text</summary>
        /// <param name="tokenText">The text for which to create the token</param>
        /// <returns>A token for the specified text</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Token CreateToken(string tokenText)
        {
            if (tokenText == null || tokenText.Length == 0) return EmptyToken;

            ITokenBuilder tokenBuilder;
            for (int x = 0; x < tokenBuilders.Length; x++)
            {
                tokenBuilder = tokenBuilders[x];
                if (tokenBuilder.Handles(tokenText))
                    return tokenBuilder.BuildToken(tokenText);
            }

            return new TextToken(tokenText);
        }
    }
}
